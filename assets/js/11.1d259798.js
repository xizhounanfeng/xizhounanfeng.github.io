(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{339:function(v,_,t){"use strict";t.r(_);var s=t(0),l=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[v._v("#")]),v._v(" 事务")]),v._v(" "),_("ul",[_("li",[v._v("定义："),_("strong",[v._v("是逻辑上的一组操作，要么都执行，要么都不执行")])]),v._v(" "),_("li",[v._v("应用场景：保证数据的一致性")]),v._v(" "),_("li",[v._v("经典案例：【转账】\n"),_("ul",[_("li",[v._v("假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败\n"),_("ul",[_("li",[v._v("将小明的余额减少 1000 元")]),v._v(" "),_("li",[v._v("将小红的余额增加 1000 元")])])]),v._v(" "),_("li",[v._v("事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败")])])])]),v._v(" "),_("h2",{attrs:{id:"数据库事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务"}},[v._v("#")]),v._v(" 数据库事务")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("作用：保证多个对数据库的操作（即 SQL 语句）构成一个逻辑上的整体")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("构成这个逻辑上的整体的这些数据库操作遵循："),_("strong",[v._v("要么全部执行成功,要么全部不执行")])]),v._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 开启一个事务")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("START")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("TRANSACTION")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 多条 SQL 语句")]),v._v("\nSQL1"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("SQL2"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("## 提交事务")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("COMMIT")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br")])])])])]),v._v(" "),_("li",[_("p",[v._v("关系型数据库事务均存在"),_("code",[v._v("ACID")]),v._v("特性")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("原子性")]),v._v("（"),_("code",[v._v("Atomicity")]),v._v("）：事务是最小的执行单位，不允许分割。事务的原子性，确保动作要么全部完成，要么完全不起作用")]),v._v(" "),_("li",[_("strong",[v._v("一致性")]),v._v("（"),_("code",[v._v("Consistency")]),v._v("）：执行事务前后，数据保持一致。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的")]),v._v(" "),_("li",[_("strong",[v._v("隔离性")]),v._v("（"),_("code",[v._v("Isolation")]),v._v("）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的")]),v._v(" "),_("li",[_("strong",[v._v("持久性")]),v._v("（"),_("code",[v._v("Durability")]),v._v("）：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响")])])])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("额外补充")]),v._v(" "),_("p",[_("strong",[v._v("只有保证了事务的原子性、隔离性、持久性之后，一致性才能得到保障")]),v._v(" 。即A、I、D是手段，C是目的")])]),v._v(" "),_("h2",{attrs:{id:"并发事务带来的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发事务带来的问题"}},[v._v("#")]),v._v(" 并发事务带来的问题")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("背景：在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（即多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题："),_("code",[v._v("脏读、丢失修改、不可重复读、幻读")])])]),v._v(" "),_("li",[_("p",[v._v("脏读(Dirty Read)")]),v._v(" "),_("ul",[_("li",[v._v("定义：一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据")]),v._v(" "),_("li",[v._v("举例：\n"),_("ul",[_("li",[v._v("事务 1 读取某表中的数据 A=20；事务 1 修改 A=A-1 --\x3e A= 19")]),v._v(" "),_("li",[v._v("事务 2 读取到 A = 19")]),v._v(" "),_("li",[v._v("事务 1 回滚导致对 A 的修改并未提交到数据库，A 的值还是 20")])])])])]),v._v(" "),_("li",[_("p",[v._v("丢失修改(Lost to Modify)")]),v._v(" "),_("ul",[_("li",[v._v("定义：在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据 --\x3e 第一个事务内的修改结果就被丢失")]),v._v(" "),_("li",[v._v("举例：\n"),_("ul",[_("li",[v._v("事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20")]),v._v(" "),_("li",[v._v("事务 1 先修改 A=A-1 --\x3e A = 19")]),v._v(" "),_("li",[v._v("事务 2 后来也修改 A=A-1 --\x3e A = 19")]),v._v(" "),_("li",[v._v("最终结果 A=19，事务 1 的修改被丢失")])])])])]),v._v(" "),_("li",[_("p",[v._v("不可重复读(Unrepeatable Read)")]),v._v(" "),_("ul",[_("li",[v._v("定义：在一个事务内多次读同一数据。在这个事务还没有结束时， 另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间， 由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样 --\x3e 发生了在一个事务内，两次读到的数据是不一样的情况")]),v._v(" "),_("li",[v._v("举例：\n"),_("ul",[_("li",[v._v("事务 1 读取某表中的数据 A=20，事务 2 读取数据 A=20")]),v._v(" "),_("li",[v._v("事务 1 修改 A=A-1 --\x3e A = 19")]),v._v(" "),_("li",[v._v("事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同")])])])])]),v._v(" "),_("li",[_("p",[v._v("幻读(Phantom Read)")]),v._v(" "),_("ul",[_("li",[v._v("定义：在一个事务中读取了几行数据，接着另一个并发事务插入了一些数据。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样【"),_("code",[v._v("幻读与不可重复读类似")]),v._v("】")]),v._v(" "),_("li",[v._v("举例：\n"),_("ul",[_("li",[v._v("事务 2 读取某个范围的数据")]),v._v(" "),_("li",[v._v("事务 1 在这个范围插入了新的数据")]),v._v(" "),_("li",[v._v("事务 2 再次读取这个范围的数据，发现相比于第一次读取的结果多了新的数据")])])])])])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("不可重复读和幻读的区别")])]),v._v(" "),_("ul",[_("li",[v._v("不可重复读的重点："),_("code",[v._v("内容修改或者记录减少")]),v._v("。比如多次读取一条记录，发现其中某些记录的值被修改")]),v._v(" "),_("li",[v._v("幻读的重点："),_("code",[v._v("记录新增")]),v._v("。比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了")]),v._v(" "),_("li",[v._v("幻读其实可以看作是不可重复读的一种特殊情况，单独区分幻读的原因：\n"),_("ul",[_("li",[v._v("主要是解决幻读和不可重复读的方案不一样")]),v._v(" "),_("li",[v._v("举例：\n"),_("ul",[_("li",[v._v("执行 "),_("code",[v._v("delete")]),v._v(" 和 "),_("code",[v._v("update")]),v._v(" 操作的时候，可以直接对记录加锁，保证事务安全 --\x3e 解决不可重复读")]),v._v(" "),_("li",[v._v("执行 "),_("code",[v._v("insert")]),v._v(" 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。即执行 "),_("code",[v._v("insert")]),v._v(" 操作的时候需要依赖 "),_("code",[v._v("Next-Key Lock")]),v._v("（"),_("code",[v._v("Record Lock")]),v._v(" + "),_("code",[v._v("Gap Lock")]),v._v("） 进行加锁来保证不出现幻读 --\x3e 解决幻读")])])])])])]),v._v(" "),_("h2",{attrs:{id:"并发事务的控制方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发事务的控制方式"}},[v._v("#")]),v._v(" 并发事务的控制方式")]),v._v(" "),_("ul",[_("li",[v._v("两种方式："),_("code",[v._v("锁")]),v._v("、"),_("code",[v._v("MVCC")]),v._v(" "),_("ul",[_("li",[v._v("锁：可以看作是悲观控制的模式")]),v._v(" "),_("li",[v._v("多版本并发控制（MVCC，Multiversion concurrency control）：可以看作是乐观控制的模式")])])]),v._v(" "),_("li",[v._v("锁：主要通过"),_("code",[v._v("读写锁")]),v._v("来实现并发控制\n"),_("ul",[_("li",[_("strong",[v._v("共享锁（S 锁）")]),v._v("：又称读锁。事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）")]),v._v(" "),_("li",[_("strong",[v._v("排他锁（X 锁）")]),v._v("：又称写锁/独占锁。事务在修改记录的时候获取排他锁，不允许多个事务同时获取\n"),_("ul",[_("li",[v._v("如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）")])])]),v._v(" "),_("li",[v._v("读写锁可以做到"),_("code",[v._v("读读并行")]),v._v("，但是"),_("code",[v._v("无法做到写读、写写并行")])])])]),v._v(" "),_("li",[v._v("MVCC：对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本\n"),_("ul",[_("li",[v._v("通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的")]),v._v(" "),_("li",[v._v("MVCC 在 MySQL 中实现所依赖的手段主要是: "),_("strong",[v._v("隐藏字段、read view、undo log")]),v._v(" "),_("ul",[_("li",[v._v("undo log : 用于记录某行数据的多个版本的数据")]),v._v(" "),_("li",[v._v("read view 和 隐藏字段 : 用来判断当前版本数据的可见性")])])])])])]),v._v(" "),_("h2",{attrs:{id:"隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别"}},[v._v("#")]),v._v(" 隔离级别")]),v._v(" "),_("ul",[_("li",[v._v("见"),_("RouterLink",{attrs:{to:"/05.数据库/01.MySQL/04.MySQL事务隔离级别详解.html"}},[v._v("MySQL事务隔离级别详解")])],1)])])}),[],!1,null,null,null);_.default=l.exports}}]);