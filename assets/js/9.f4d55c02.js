(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{335:function(_,v,l){"use strict";l.r(v);var t=l(0),e=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"索引介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引介绍"}},[_._v("#")]),_._v(" 索引介绍")]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("点睛")]),_._v(" "),v("p",[v("strong",[_._v("索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构")])])]),_._v(" "),v("ul",[v("li",[_._v("索引的作用就相当于书的目录\n"),v("ul",[v("li",[_._v("举例：\n"),v("ul",[v("li",[_._v("在查字典的时候，如果没有目录，就只能一页一页的去找需要查的那个字，速度很慢")]),_._v(" "),v("li",[_._v("如果有目录，只需要先去目录里查找字的位置，然后直接翻到那一页")])])])])]),_._v(" "),v("li",[_._v("索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树\n"),v("ul",[v("li",[_._v("在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构【二者实现方式不同】")])])])]),_._v(" "),v("h2",{attrs:{id:"索引的优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引的优缺点"}},[_._v("#")]),_._v(" 索引的优缺点")]),_._v(" "),v("ul",[v("li",[_._v("优点\n"),v("ul",[v("li",[_._v("使用索引可以大大加快数据的检索速度（大大减少检索的数据量）【创建索引的主要原因】")]),_._v(" "),v("li",[_._v("通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性")])])]),_._v(" "),v("li",[_._v("缺点\n"),v("ul",[v("li",[_._v("创建索引和维护索引需要耗费时间\n"),v("ul",[v("li",[_._v("当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会"),v("code",[_._v("降低 SQL 执行效率")])])])]),_._v(" "),v("li",[_._v("索引需要使用物理文件存储，也会耗费一定空间")])])]),_._v(" "),v("li",[v("strong",[_._v("使用索引一定能提高查询效率吗？")]),_._v(" "),v("ul",[v("li",[_._v("一般情况：索引查询都比全表扫描要快")]),_._v(" "),v("li",[_._v("个别情况：如果数据库的数据量不大的话，那么使用索引不一定能带来很大提升")])])])]),_._v(" "),v("h2",{attrs:{id:"索引类型总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引类型总结"}},[_._v("#")]),_._v(" 索引类型总结")]),_._v(" "),v("h3",{attrs:{id:"_01-数据结构维度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_01-数据结构维度"}},[_._v("#")]),_._v(" 01. 数据结构维度：")]),_._v(" "),v("ul",[v("li",[_._v("B+Tree 索引：\n"),v("ul",[v("li",[_._v("MySQL默认和最常用的索引类型")]),_._v(" "),v("li",[_._v("只有叶子节点存储value，非叶子节点只有指针和key")]),_._v(" "),v("li",[_._v("存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不同")])])]),_._v(" "),v("li",[_._v("哈希索引：类似键值对的形式，一次即可定位")]),_._v(" "),v("li",[_._v("RTree 索引：\n"),v("ul",[v("li",[_._v("一般不会使用，仅支持 geometry 数据类型")]),_._v(" "),v("li",[_._v("优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替")])])]),_._v(" "),v("li",[_._v("全文索引：\n"),v("ul",[v("li",[_._v("对文本的内容进行分词，进行搜索")]),_._v(" "),v("li",[_._v("目前只有 "),v("code",[_._v("CHAR")]),_._v("、"),v("code",[_._v("VARCHAR")]),_._v(" ，"),v("code",[_._v("TEXT")]),_._v(" 列上可以创建全文索引")]),_._v(" "),v("li",[_._v("一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替")])])])]),_._v(" "),v("h3",{attrs:{id:"_02-底层存储方式维度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_02-底层存储方式维度"}},[_._v("#")]),_._v(" 02. 底层存储方式维度")]),_._v(" "),v("ul",[v("li",[_._v("聚簇索引（聚集索引）："),v("code",[_._v("索引结构和数据一起存放")]),_._v("的索引\n"),v("ul",[v("li",[_._v("InnoDB 中的主键索引就属于聚簇索引")])])]),_._v(" "),v("li",[_._v("非聚簇索引（非聚集索引）："),v("code",[_._v("索引结构和数据分开存放")]),_._v("的索引\n"),v("ul",[v("li",[_._v("二级索引(辅助索引)就属于非聚簇索引")]),_._v(" "),v("li",[_._v("MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引")])])])]),_._v(" "),v("h3",{attrs:{id:"_03-应用维度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_03-应用维度"}},[_._v("#")]),_._v(" 03. 应用维度")]),_._v(" "),v("ul",[v("li",[_._v("主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个")]),_._v(" "),v("li",[_._v("普通索引：仅加速查询")]),_._v(" "),v("li",[_._v("唯一索引：加速查询 + 列值唯一（可以有 NULL）")]),_._v(" "),v("li",[_._v("覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值")]),_._v(" "),v("li",[_._v("联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并")]),_._v(" "),v("li",[_._v("全文索引：对文本的内容进行分词，进行搜索")])]),_._v(" "),v("h2",{attrs:{id:"主键索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主键索引"}},[_._v("#")]),_._v(" 主键索引")]),_._v(" "),v("ul",[v("li",[_._v("数据表的"),v("code",[_._v("主键列")]),_._v("使用的就是"),v("code",[_._v("主键索引")])]),_._v(" "),v("li",[_._v("一张数据表有只能有一个主键，并且主键不能为 null，不能重复")]),_._v(" "),v("li",[_._v("InnoDB 引擎的表，当没有显示的指定表的主键时，进行如下操作：\n"),v("ul",[v("li",[_._v("自动先检查表中是否有唯一索引且不允许存在 null 值的字段\n"),v("ul",[v("li",[_._v("存在 --\x3e 则选择该字段为默认的主键")]),_._v(" "),v("li",[_._v("不存在 --\x3e InnoDB 将会自动创建一个 6Byte 的自增主键")])])])])]),_._v(" "),v("li",[_._v("主键索引数据结构【B+Tree索引】如下：")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/cluster-index.png",alt:""}})]),_._v(" "),v("h2",{attrs:{id:"二级索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二级索引"}},[_._v("#")]),_._v(" 二级索引")]),_._v(" "),v("ul",[v("li",[_._v("二级索引（Secondary Index）的叶子节点存储的数据是主键的值\n"),v("ul",[v("li",[_._v("通过二级索引可以定位主键的位置，二级索引又称为"),v("code",[_._v("辅助索引/非主键索引")])])])]),_._v(" "),v("li",[v("code",[_._v("唯一索引")]),_._v("、"),v("code",[_._v("普通索引")]),_._v("、"),v("code",[_._v("前缀索引")]),_._v("等索引均属于二级索引")]),_._v(" "),v("li",[_._v("二级索引数据结构如下：")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/no-cluster-index.png",alt:""}})]),_._v(" "),v("h2",{attrs:{id:"聚簇索引与非聚簇索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引与非聚簇索引"}},[_._v("#")]),_._v(" 聚簇索引与非聚簇索引")]),_._v(" "),v("h3",{attrs:{id:"_01-聚簇索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_01-聚簇索引"}},[_._v("#")]),_._v(" 01. 聚簇索引")]),_._v(" "),v("ul",[v("li",[_._v("介绍：\n"),v("ul",[v("li",[_._v("聚簇索引（Clustered Index）即"),v("code",[_._v("索引结构和数据一起存放")]),_._v("的索引，并不是一种单独的索引类型\n"),v("ul",[v("li",[_._v("InnoDB 中的主键索引属于聚簇索引")])])]),_._v(" "),v("li",[_._v("InnoDB 引擎的表的 "),v("code",[_._v(".ibd")]),_._v("文件包含该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据")])])]),_._v(" "),v("li",[_._v("优缺点\n"),v("ul",[v("li",[_._v("优点：\n"),v("ul",[v("li",[v("strong",[_._v("查询速度非常快")]),_._v("：\n"),v("ul",[v("li",[_._v("整个 B+树本身就是一颗多叉平衡树，叶子节点都是有序的，定位到索引的节点，就相当于定位到数据")]),_._v(" "),v("li",[_._v("相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作 【即回表】")])])]),_._v(" "),v("li",[v("strong",[_._v("对排序查找和范围查找优化")]),_._v("：聚簇索引对于主键的排序查找和范围查找速度非常快")])])]),_._v(" "),v("li",[_._v("缺点：\n"),v("ul",[v("li",[v("strong",[_._v("依赖于有序的数据")]),_._v("：\n"),v("ul",[v("li",[_._v("B+树是多路平衡树，若索引的数据不是有序的，则需要在插入时排序")]),_._v(" "),v("li",[_._v("如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢")])])]),_._v(" "),v("li",[v("strong",[_._v("更新代价大")]),_._v("：如果索引列的数据被修改，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于"),v("code",[_._v("主键索引")]),_._v("来说，"),v("code",[_._v("主键")]),_._v("一般都是"),v("code",[_._v("不可被修改")]),_._v("的")])])])])])]),_._v(" "),v("h3",{attrs:{id:"_02-非聚簇索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_02-非聚簇索引"}},[_._v("#")]),_._v(" 02. 非聚簇索引")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("介绍：")]),_._v(" "),v("ul",[v("li",[_._v("非聚簇索引(Non-Clustered Index)即"),v("code",[_._v("索引结构和数据分开存放")]),_._v("的索引，并不是一种单独的索引类型\n"),v("ul",[v("li",[_._v("二级索引(辅助索引)就属于非聚簇索引")]),_._v(" "),v("li",[_._v("MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引")])])]),_._v(" "),v("li",[_._v("非聚簇索引的叶子节点并不一定存放数据的指针\n"),v("ul",[v("li",[_._v("因为二级索引的叶子节点就存放的是主键，根据主键再"),v("code",[_._v("回表")]),_._v("查寻数据")])])])])]),_._v(" "),v("li",[v("p",[_._v("优缺点：")]),_._v(" "),v("ul",[v("li",[_._v("优点：\n"),v("ul",[v("li",[_._v("更新代价比聚簇索引要小。非聚簇索引的叶子节点是不存放数据的")])])]),_._v(" "),v("li",[_._v("缺点：\n"),v("ul",[v("li",[v("strong",[_._v("依赖于有序的数据")]),_._v("：与聚簇索引一样，非聚簇索引也依赖于有序的数据")]),_._v(" "),v("li",[v("strong",[_._v("可能会二次查询(回表)")]),_._v(":非聚簇索引最大的缺点。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询")])])])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("非聚簇索引一定会回表查询【覆盖索引】吗")])]),_._v(" "),v("ul",[v("li",[_._v("不一定")]),_._v(" "),v("li",[_._v("示例一：用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引")])]),_._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("SELECT name FROM table WHERE name='xizhounanfeng';\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("该索引的 key 本身就是 name，查到对应的 name 直接返回，无需回表查询")])])]),_._v(" "),v("h2",{attrs:{id:"覆盖索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[_._v("#")]),_._v(" 覆盖索引")]),_._v(" "),v("ul",[v("li",[_._v("定义："),v("code",[_._v("一个索引包含（或者说覆盖）所有需要查询的字段的值")])])]),_._v(" "),v("div",{staticClass:"custom-block note"},[v("p",{staticClass:"custom-block-title"},[_._v("回表操作")]),_._v(" "),v("p",[_._v("在 InnoDB 存储引擎中，非主键索引的叶子节点包含的是主键的值。这意味着，当使用非主键索引进行查询时，数据库会"),v("code",[_._v("先找到对应的主键值")]),_._v("，然后再"),v("code",[_._v("通过主键索引来定位和检索完整的行数据")])])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据，而无需回表查询")])])]),_._v(" "),v("h2",{attrs:{id:"联合索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#联合索引"}},[_._v("#")]),_._v(" 联合索引")]),_._v(" "),v("ul",[v("li",[_._v("定义：使用表中的多个字段创建索引，又称"),v("code",[_._v("组合索引")]),_._v("或"),v("code",[_._v("复合索引")])])]),_._v(" "),v("h2",{attrs:{id:"最左前缀匹配原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#最左前缀匹配原则"}},[_._v("#")]),_._v(" 最左前缀匹配原则")]),_._v(" "),v("ul",[v("li",[_._v("定义：在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率")])]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("原则")]),_._v(" "),v("p",[_._v("最左匹配原则会一直向右匹配，直到遇到"),v("code",[_._v("范围查询（如 >、<）为止")]),_._v("。对于 "),v("code",[_._v(">=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配")])])]),_._v(" "),v("h2",{attrs:{id:"b-tree-索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-索引"}},[_._v("#")]),_._v(" B+Tree 索引")]),_._v(" "),v("ul",[v("li",[_._v("MySQL 的 InnoDB 存储引擎会为每一张数据库表创建一个「聚簇索引」来保存表的数据【即主键索引】\n"),v("ul",[v("li",[_._v("聚簇索引默认使用的是 "),v("strong",[_._v("B+Tree 索引")])])])])]),_._v(" "),v("p",[v("strong",[_._v("示例【用于说明B+Tree 索引在存储数据中的具体实现】")])]),_._v(" "),v("ul",[v("li",[_._v("商品表如下：")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/produce.jpg",alt:""}})]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("主键索引")]),_._v(" "),v("p",[_._v("B+Tree 是一种多叉树，叶子节点存放数据，非叶子节点只存放索引，而且每个节点里的数据是"),v("strong",[_._v("按主键值（id）顺序存放")]),_._v("的，每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表，便于范围查询")])]),_._v(" "),v("ul",[v("li",[_._v("聚簇索引的 B+Tree 如图所示：")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/b+tree-01.jpg",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"_01-索引查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_01-索引查询"}},[_._v("#")]),_._v(" 01. 索引查询")]),_._v(" "),v("ul",[v("li",[_._v("执行"),v("code",[_._v("select * from t_product where id = 5")]),_._v("查询语句\n"),v("ul",[v("li",[_._v("因为B+Tree 是一个"),v("strong",[_._v("有序")]),_._v("的数据结构，所以可以通过二分查找算法快速定位到这条记录")])])]),_._v(" "),v("li",[_._v("具体过程：\n"),v("ul",[v("li",[_._v("从根节点开始，将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，根据二分查找算法，找到第二层的索引数据 (1，4，7)")]),_._v(" "),v("li",[_._v("在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，根据二分查找算法，找到第三层的索引数据（4，5，6）")]),_._v(" "),v("li",[_._v("在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的这条记录")])])])]),_._v(" "),v("h3",{attrs:{id:"_02-二级索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_02-二级索引"}},[_._v("#")]),_._v(" 02. 二级索引")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("聚簇索引")]),_._v("只能用于"),v("code",[_._v("主键字段")]),_._v("的快速查询")]),_._v(" "),v("li",[_._v("若想实现"),v("code",[_._v("「非主键字段」")]),_._v("的快速查询，我们就要针对「非主键字段」创建索引，即二级索引\n"),v("ul",[v("li",[v("code",[_._v("二级索引的叶子节点存放的是主键值，不是实际数据")])])])])]),_._v(" "),v("p",[_._v("将商品表中的 product_no （商品编码）字段设置为二级索引，那么二级索引的 B+Tree 如下图【其中非叶子的索引值是 product_no（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）】：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/b+tree-02.jpg",alt:""}})]),_._v(" "),v("ul",[v("li",[v("p",[_._v("执行"),v("code",[_._v("select * from product where product_no = '0002';")]),_._v("查询语句")])]),_._v(" "),v("li",[v("p",[_._v("执行过程：")]),_._v(" "),v("ul",[v("li",[_._v("在二级索引的 B+Tree 中快速查找到 product_no 为 0002 的二级索引记录，然后获取主键值")]),_._v(" "),v("li",[_._v("利用主键值在主键索引的 B+Tree 中快速查询到对应的叶子节点，然后获取完整的记录")])])]),_._v(" "),v("li",[v("p",[_._v("上述执行过程是"),v("code",[_._v("回表")]),_._v("，即要查两个 B+Tree 才能查到数据，如下图：")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/b+tree-03.jpg",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"_03-覆盖索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_03-覆盖索引"}},[_._v("#")]),_._v(" 03. 覆盖索引")]),_._v(" "),v("ul",[v("li",[_._v("当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引\n"),v("ul",[v("li",[_._v("比如执行"),v("code",[_._v("select id from product where product_no = '0002';")]),_._v("查询语句")])])]),_._v(" "),v("li",[_._v("在二级索引的 B+Tree 就能查询到结果的过程就叫作「"),v("strong",[_._v("覆盖索引")]),_._v("」，即只需要查一个 B+Tree 就能找到数据")])]),_._v(" "),v("h3",{attrs:{id:"_04-联合索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_04-联合索引"}},[_._v("#")]),_._v(" 04. 联合索引")]),_._v(" "),v("ul",[v("li",[_._v("以商品表为例，product_no 和 name 字段组合成联合索引\n"),v("ul",[v("li",[_._v("执行"),v("code",[_._v("CREATE INDEX index_product_no_name ON product(product_no, name);")]),_._v("创建联合索引")])])]),_._v(" "),v("li",[_._v("联合索引 ``(product_no, name)` 的 B+Tree 示意图如下：")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/b+tree-04.jpg",alt:""}})]),_._v(" "),v("ul",[v("li",[_._v("从上图联合索引的非叶子节点用两个字段的值作为 B+Tree 的索引值")])]),_._v(" "),v("div",{staticClass:"custom-block note"},[v("p",{staticClass:"custom-block-title"},[_._v("重要点")]),_._v(" "),v("p",[_._v("联合索引的 B+Tree 是先按 "),v("code",[_._v("product_no")]),_._v(" 进行排序，然后再 "),v("code",[_._v("product_no")]),_._v(" 相同的情况再按 "),v("code",[_._v("name")]),_._v(" 字段排序")])]),_._v(" "),v("h3",{attrs:{id:"_05-最左前缀匹配原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_05-最左前缀匹配原则"}},[_._v("#")]),_._v(" 05. 最左前缀匹配原则")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性")])]),_._v(" "),v("li",[v("Badge",{attrs:{text:"示例1",vertical:"middle"}}),_._v("：创建联合索引(a, b, c) \n"),v("ul",[v("li",[v("p",[_._v("联合索引生效：查询优化器的存在，使得 a 字段在 where 子句的顺序并不重要")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("where a=1")])]),_._v(" "),v("li",[v("code",[_._v("where a=1 and b=2 and c=3")])]),_._v(" "),v("li",[v("code",[_._v("where a=1 and b=2")])])])]),_._v(" "),v("li",[v("p",[_._v("联合索引失效：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("where b=2")])]),_._v(" "),v("li",[v("code",[_._v("where c=3")])]),_._v(" "),v("li",[v("code",[_._v("where b=2 and c=3")])])]),_._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[_._v("失效原因")]),_._v(" "),v("p",[_._v("因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，"),v("code",[_._v("b 和 c 是全局无序，局部相对有序的")]),_._v("，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的")])])])])],1),_._v(" "),v("li",[v("Badge",{attrs:{text:"示例2",vertical:"middle"}}),_._v("：创建联合索引（a，b）-- 加深理解联合索引生效和失效\n"),v("ul",[v("li",[_._v("该联合索引的 B+ Tree 如下：")])])],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/b+tree-05.jpg",alt:""}})]),_._v(" "),v("ul",[v("li",[_._v("从上图可以看到：\n"),v("ul",[v("li",[_._v("a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），b 是全局是无序的（12，7，8，2，3，8，10，5，2）\n"),v("ul",[v("li",[_._v("直接执行 "),v("code",[_._v("where b = 2")]),_._v(" 这种查询条件是没有办法利用联合索引的，"),v("strong",[_._v("利用索引的前提是索引里的 key 是有序的")])])])]),_._v(" "),v("li",[_._v("只有在 a 相同的情况下，b 才是有序的\n"),v("ul",[v("li",[_._v("比如 a = 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的")]),_._v(" "),v("li",[_._v("执行 "),v("code",[_._v("where a = 2 and b = 7")]),_._v(" 这种查询条件时， a 和 b 字段能用到联合索引的，即联合索引生效")])])])])])]),_._v(" "),v("h3",{attrs:{id:"_06-联合索引范围查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_06-联合索引范围查询"}},[_._v("#")]),_._v(" 06. 联合索引范围查询")]),_._v(" "),v("ul",[v("li",[_._v("联合索引存在一种特殊情况：部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree")]),_._v(" "),v("li",[_._v("范围查询时，会出现上面的特殊情况：\n"),v("ul",[v("li",[v("strong",[_._v("联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配")])]),_._v(" "),v("li",[_._v("即"),v("code",[_._v("范围查询的字段可以用到联合索引，但是范围查询字段的后面的字段无法用到联合索引")])])])])]),_._v(" "),v("Badge",{attrs:{text:"示例1",vertical:"middle"}}),_._v(" "),v("div",{staticClass:"custom-block danger"},[v("p",{staticClass:"custom-block-title"},[_._v("Q1")]),_._v(" "),v("p",[v("code",[_._v("select * from t_table where a > 1 and b = 2")]),_._v(" --\x3e 联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？")])]),_._v(" "),v("ul",[v("li",[_._v("a 字段可以在联合索引的 B+Tree 中进行索引查询\n"),v("ul",[v("li",[_._v("由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻的")]),_._v(" "),v("li",[_._v("在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a > 1 条件位置")])])]),_._v(" "),v("li",[_._v("b 字段不可以在联合索引的 B+Tree 中进行索引查询\n"),v("ul",[v("li",[_._v("在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的")])])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/b+tree-06.jpg",alt:""}})]),_._v(" "),v("ul",[v("li",[_._v("下面这三条记录的 a 字段的值都符合 a > 1 查询条件，而 b 字段的值是无序的：\n"),v("ul",[v("li",[_._v("a 字段值为 5 的记录，该记录的 b 字段值为 8")]),_._v(" "),v("li",[_._v("a 字段值为 6 的记录，该记录的 b 字段值为 10")]),_._v(" "),v("li",[_._v("a 字段值为 7 的记录，该记录的 b 字段值为 5")])])]),_._v(" "),v("li",[_._v("因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量，即 b 字段无法利用联合索引进行索引查询")]),_._v(" "),v("li",[_._v("总结："),v("strong",[_._v("Q1 查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引")])])]),_._v(" "),v("p",[_._v("============================ 分割线 ============================")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("此外，还可采取"),v("code",[_._v("EXPLAIN执行计划")]),_._v("了解到这一点")]),_._v(" "),v("ul",[v("li",[_._v("在使用联合索引进行查询的时候，"),v("strong",[_._v("通过 key_len 我们可以知道优化器具体使用了多少个字段的查询条件来形成扫描区间的边界条件")])])])]),_._v(" "),v("li",[v("p",[_._v("若 a 和 b 都是 int 类型且不为 NULL 的字段，那么 Q1 查询语句执行计划如下：")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/b+tree-07.jpg",alt:""}})]),_._v(" "),v("ul",[v("li",[_._v("分析：\n"),v("ul",[v("li",[_._v("key_len 为 4 字节（"),v("em",[_._v("如果字段允许为 NULL，就在字段类型占用的字节数上加 1，也就是 5 字节")]),_._v("），说明只有 a 字段用到了联合索引进行索引查询")]),_._v(" "),v("li",[_._v("即使 b 字段没用到联合索引，key 为 idx_a_b，也说明 Q1 查询语句使用了 idx_a_b 联合索引")])])]),_._v(" "),v("li",[_._v("结论："),v("strong",[_._v("a 字段使用了 > 进行范围查询，联合索引的最左匹配原则在遇到 a 字段的范围查询（ >）后就停止匹配了，因此 b 字段并没有使用到联合索引")])])]),_._v(" "),v("Badge",{attrs:{text:"示例2",vertical:"middle"}}),_._v(" "),v("div",{staticClass:"custom-block danger"},[v("p",{staticClass:"custom-block-title"},[_._v("Q2")]),_._v(" "),v("p",[v("code",[_._v("select * from t_table where a >= 1 and b = 2")]),_._v(" --\x3e 联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？")])]),_._v(" "),v("ul",[v("li",[_._v("a 字段可以在联合索引的 B+Tree 中进行索引查询\n"),v("ul",[v("li",[_._v("联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a >= 1 条件的二级索引记录肯定是相邻")]),_._v(" "),v("li",[_._v("在进行索引扫描的时候，可以定位到符合 a >= 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a >= 1 条件位置")])])]),_._v(" "),v("li",[_._v("b 字段可以在联合索引的 B+Tree 中进行索引查询\n"),v("ul",[v("li",[_._v("虽然在符合 a >= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，"),v("strong",[_._v("但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的")]),_._v("（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）")]),_._v(" "),v("li",[_._v("在确定需要扫描的二级索引的范围时，当二级索引记录的 a = 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围，即 b 字段可以利用联合索引进行索引查询。从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描")])])]),_._v(" "),v("li",[_._v("总结："),v("strong",[_._v("Q2 查询语句 a 和 b 字段都用到了联合索引进行索引查询")])])]),_._v(" "),v("p",[_._v("============================ 分割线 ============================")]),_._v(" "),v("ul",[v("li",[_._v("若 a 和 b 都是 int 类型且不为 NULL 的字段，那么 Q2 查询语句执行计划如下：")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.onmicrosoft.cn/gh/xizhounanfeng/blogImg/images/mysql/b+tree-08.jpg",alt:""}})]),_._v(" "),v("ul",[v("li",[_._v("分析：key_len 为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，即 a 和 b 字段都用到了联合索引进行索引查询")]),_._v(" "),v("li",[_._v("结论："),v("strong",[_._v("虽然 a 字段使用了 >= 进行范围查询，但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（ >=）后就停止匹配了，b 字段还是可以用到了联合索引的")])])])],1)}),[],!1,null,null,null);v.default=e.exports}}]);